---
title: "Avanced structural equation modeling"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
header-includes:
   - \usepackage{svg}
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("here")
```



# Load data and rerun the model
Here, we use the very same data set as in the introductory part to SEM (`1_basic_modeling.html`).
Also, we rescale the biomass and precipitation so that they are in approximately the same range as the other variables.


```{r}
seabloom <- read.table(here("2_Modeling/Data_preparation/seabloom-2020-ele-dryad-data/cdr-e001-e002-output-data.csv"),
                       sep = ",", header = TRUE)
# seabloom <- read.table("~/repos/Swiss_SEM/2_Modeling/Data_preparation/seabloom-2020-ele-dryad-data/cdr-e001-e002-output-data.csv",
#                        sep = ",", header = TRUE)
# seabloom <- seabloom[seabloom$year == 2000, ]

seabloom$mass.above <- seabloom$mass.above / 100
seabloom$precip.mm <- seabloom$precip.mm / 100
seabloom$precip.gs <- seabloom$precip.gs / 100

seabloom.agg <- aggregate(list(rich = seabloom$rich, even = seabloom$even,
                               ens.pie = seabloom$ens.pie, 
                               mass.above = seabloom$mass.above, 
                               precip.mm = seabloom$precip.mm,
                               precip.gs = seabloom$precip.gs),
                          by = list(year = seabloom$year,
                                    nadd = seabloom$nadd,
                                    ntrt = seabloom$ntrt,
                                    disk = seabloom$disk, 
                                    field = seabloom$field),
                          FUN = mean, data = seabloom)
```



## Rerun the model
First, we rerun the model as before.


![](Figures/SimplePrecSEM.svg){width=60%}


```{r}
library("lavaan")

simple <-
"mass.above ~ nadd + disk + rich + even + precip.mm
rich ~ nadd + precip.mm
even ~ nadd + precip.mm

rich ~~ even"

fit.simple <- sem(simple, data = seabloom, estimator = "MLM")
summary(fit.simple)
```





# Latent and composite variables
- difference between latent and composite variable
- SEM with latent variable(s)
- SEM with composite variable(s)

![](Figures/LatentCompositeSEM.svg){width=50%}


## Latent variable
Let's first create a latent variable "diversity" from the two measurements of diversity (richness and evenness).


Indicators for a LV should be positively correlated with each other.
It's not.
Take the inverse of evenness ():

```{r}
cor(seabloom$even, seabloom$rich)

seabloom$even.rev <- -1 * seabloom$even
cor(seabloom$even.rev, seabloom$rich)
```


Grace et al. 2021:

1. we expect the indicators to be correlated with one another. If we fail to find significant correlations (based on standard tests and null hypothesis testing, p < 0.05, then the indicators are not varying in concert and the data will not support the claim of a latent cause.
```{r}
# cor.test(seabloom$precip.mm, seabloom$precip.gs)
# cor.test(seabloom$precip.mm, seabloom$nadd)
# cor.test(seabloom$precip.gs, seabloom$nadd)

cor.test(seabloom$even.rev, seabloom$rich)
cor.test(seabloom$even.rev, seabloom$ens.pie)
cor.test(seabloom$rich, seabloom$ens.pie)
```



2. It is customary in SEM practice to analyse latent variable models in two stages, first evaluating the fit between latent variables and indicators (Fig. 5A) and...
```{r}
# cfa.prec <- 'prec =~ precip.mm + precip.gs'


var(seabloom$rich)
var(seabloom$even)
var(seabloom$ens.pie)

seabloom$rich.var <- seabloom$rich / 10
var(seabloom$rich.var)

# cfa.prec <- 'prec =~ lambda1*rich + lambda2*even.rev + lambda3*ens.pie'
# cfa.prec <- 'prec =~ lambda*rich + lambda*even.rev + lambda*ens.pie'
# cfa.prec <- 'prec =~ rich + even.rev + ens.pie + nadd'
cfa.prec <- 'prec =~ nadd + ntrt + other.add + disk'

cfa.fit <- sem(cfa.prec, data = seabloom, estimator = "MLM")
summary(cfa.fit, fit.measures = TRUE)

modindices(cfa.fit)

```


1. ...then second, evaluating the full model (e.g. Fig. 6). SE models that include only latent variables and their indicators are often referred to as confirmatory factor analysis (CFA) models




* Latent variable models with only 2 indicators are locally non-
identified. To solve this problem, we can (a) ensure x1 and x2 have
equal variances, in this case by standardizing the data. (2) When latent
variables are included we must specify a fixed value for some
parameter associated with the LV to achieve identification. The lavaan
default is to set the loading from the LV to the first-mentioned indicator
to 1.0. (3) For single-indicator LVs, the default measurement error is
set to 0.0. [@grace21]


```{r}
round(cor(seabloom[, c(7, 11:17)]), digits=2)


lv <-
"diversity =~ rich + even.rev + ens.pie
rain =~ precip.mm + precip.gs"

cfa.lv <- cfa(lv, seabloom)
summary(cfa.lv)

varTable(cfa.lv)
```


```{r}
lv <-"
# Latent variable definition
diversity =~ rich + even

mass.above ~ nadd + disk + diversity
diversity ~ nadd"

fit.lv <- sem(lv, data = seabloom, estimator = "MLM")
summary(fit.lv)
```


## Composite variable
Now, from the landuse parameters, we can create a composite variable...

```{r}
comp <- '
landuse <~ disk + nadd + ntrt

rich ~ nadd
even ~ nadd

mass.above ~ rich + even + landuse'


fit.comp <- sem(comp, data = seabloom)

summary(fit.comp)
```



<!-- ```{r} -->
<!-- compositeModel <- ' -->
<!--     #1) define the composite, scale to logN -->
<!--     Nitrogen ~ 1*logN + logNcen2 #loading on the significant path! -->
<!--   -->
<!--     #2) Specify 0 error variance -->
<!--     Nitrogen ~~ 0*Nitrogen -->
<!--  -->
<!--       #3) now, because we need to represent this as a latent variable -->
<!--       #show how species richness is an _indicator_ of nitrogen -->
<!--       Nitrogen =~ SA -->
<!--   -->
<!--     #4) BUT, make sure the variance of SA is estimated -->
<!--       SA ~~ SA -->
<!--   -->
<!--    #Regional Richness also has an effect -->
<!--     SA ~ SR -->
<!--   -->
<!--     #And account for the derivation of the square term from the linear term -->
<!--     logNcen2 ~ logN -->
<!--       ' -->
<!--   -->
<!--  # we specify std.lv=T so that the Nitrogen-SA relationship isn't fixed to 1 -->
<!--  compositeFit <- sem(compositeModel, data = seabloom, std.lv = TRUE) -->
<!--  -->
<!-- ```  -->




# Interactions
![](Figures/InteractionSEM.svg){width=70%}


# Complex sampling structure
Often, we encounter more complex sampling or experimental schemes, e.g. the data is nested within sites or contains groups with non-random differences such as sexes or lifestages.
As a result, these data violate the principle of being [*i.i.d.* (independent and identically distributed)](https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables).
Thus, it is necessary to account for this structure in the data in the model.


The add-on package [`lavaan.survey`](https://cran.r-project.org/web/packages/lavaan.survey/index.html) allows the analysis of stratified, clustered or weighted data with the help of the package [`survey`](https://r-survey.r-forge.r-project.org/survey/).
With this, `lavaan` objects can be processed further with a specific data structure:
first, we initialize the design and then, post-process the `lavaan` object and compute the adjusted results.
The result is a corrected `lavaan` object.

```{r, message=FALSE}
library("lavaan.survey")
```


As sampling was performed in `r length(unique(seabloom$plot))` plots nested in three  different fields (`A`, `B` and `C`), let's adjust for this structure.
For this, we first specify the study design as plots (`ids`) to be nested within fields (`strata`).
Next, we can refit the model with `lavaan.survey` using the specified study design as an argument.


```{r}
design <- svydesign(ids = ~ plot, strata = ~ field, nest = TRUE, 
                    data = seabloom)


fit.simple.nest <- lavaan.survey(lavaan.fit = fit.simple,
                                 survey.design = design)
summary(fit.simple.nest, fit.measures = TRUE, rsq = TRUE)
```


<!-- Two warnings pop up: -->
<!-- * The first one indicates that the `variance-covariance matrix of the estimated parameters (vcov) does not appear to be positive definite!`. However, the  smallest eigenvalue of -5.215416e-17 is very close to zero, what is likely due to  machine-precision. -->
<!-- * The second one might point to a sample size issue: for the year 2000 we have `r dim(seabloom)[1]` observations. Split into the three fields `A`, `B` and `C`, there are `r table(seabloom$field)[1:2]` and `r table(seabloom$field)[3]` observations in these three fields, respectively. With `r fit.simple.nest@Fit@npar` free parameters, this refers to `r round(table(seabloom$field)[1:2] / fit.simple.nest@Fit@npar, digits = 1)` and `r round(table(seabloom$field)[3] / fit.simple.nest@Fit@npar, digits = 1)`  samples per free parameter. -->
<!-- **This is actually low and might be the reason of the failed model fitting.** -->



## Autocorrelation (temporal, spatial)
See Byrnes' material



# Model pruning?
Now, let's delete all non-significant paths from the model to obtain the most parsimonous model.
This, however, leads to a poor model fit.


```{r}
sem.prune <-
"mass.above ~ nadd + rich
rich ~ nadd
even ~ nadd 

rich ~~ even"

fit.sem.prune <- sem(sem.prune, data = seabloom)
summary(fit.sem.prune, rsq = TRUE)
```

